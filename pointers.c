#include <stdio.h>
#include <stdint.h>
#include <stdlib.h>
/*
int main(){
    int * array_int;
    array_int = malloc(sizeof(int) * 10);
    char * string = "first string";
    char ** str;
    str = malloc(sizeof{})
    int index = 0;
    while(string[index]){
        printf("%c\n", string[index]);
        index++;
    }
    index = 0;
    while(index < 10){
        array_int[index] = index;
        index++;
    }
}
    //uint32_t * nums = (uint32_t *) 0x0001; // 0x0001 | 01 00 00 00, 02 00 00 00, 03 00 00 00
    // nums = an integer of 0x0001 - not a legal address
// or
    //uint32_t nums[] = { 1, 2, 3 };
    // nums = an integer pointer generated by the compiler linker; points to somwhere in the data section of the executable
    // pointer is legal
    //0x0001 | 01 00 00 00, 02 00 00 00, 03 00 00 00
    uint32_t * nums = (uint32_t *) 0x0001;

    printf("%i \n", *nums);   // = 1
    printf("%i \n", nums[0]); // = 1
    printf("%i \n", nums[1]); // = 2
    printf("%i \n", nums[2]); // = 2


    printf("%p \n", nums);        // 0x0001
    printf("%p \n", &nums[0]);    // 0x0001
    printf("%p \n", &nums[1]);    // 0x0001 + sizeof(uint32_t)
    printf("%p \n", &nums[2]);    // 0x0001 + sizeof(uint32_t) + sizeof(uint32_t)
    int a = 2;
    int *p = &a;
    printf("%d\n", p[10]);
    //printf("%d", sizeof(int));
}

int main(){
    int a = 0;
    int * p = &a;

    printf("%p\n", p);
    printf("%p\n", &p[10]);

    printf("%p\n", p + 10);
}

*/
#include <stdio.h>
#include <stdlib.h>

void modify(char *string);
int main()
{/*
    //first, let's take a look at the behavior of a simple variable with the operators * and &
    int x; //declaration
    x = 4; //initialization, aka, putting 4 inside x, or assigning x to 4, or setting x's content as 4

    printf("Content in x: %d\n", x);
    printf("Address of x: %dn", &x);
    printf("Content in x: %d\n", *(&x));

    printf("(Address of x) + (1 * 4) bytes (size of an int in memory): %d\n", (&x)+1);
    //^^^ when you set up the variable as type int adding 1 to its address will add actually 4 bytes behind the scenes, because that's the size of an int in computer memory.
    printf("Content in ((address of x) + 4 bytes): %d //garbage value\n", *(&x + 1));

    int* pointer_to_x;
    pointer_to_x = &x;

    printf("Content in x / content of the variable pointed by pointer_to_x: %d \n", *(pointer_to_x));
    printf("Address of pointer_to_x: %d\n", pointer_to_x);*/
    char **array = malloc(sizeof(char *) * 10);
    int index = 0;
    int index_string;

    while (index < 10) {
        index_string = 0;
        array[index] = malloc(sizeof(char) * 10);
        while (index_string < 10) {
            array[index][index_string] = '0' + index_string;

            index_string++;
        }
        modify(array[index]);
        printf("%s\n", array[index]);
        index++;
    }

    return 0;
}
void modify(char *string){
    int index = 0;
    char c = 'a';
    while(index <10) {
        string[index] = c + index;
        index++;
    }
}